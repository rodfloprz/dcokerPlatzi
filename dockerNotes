To find a process inside a container we need to inspect out json file.

docker inspect --format '{{.State.Pid}}' always-up

important to mention that if we use -d option docker is going to look for the entry point section to execute the main command


Mongo container has a binary "mongo" command to use it as a client and use the database

use platzi

db.users.insert({"nombre": "rodrigo"})
db.users.find()

To persist (bind mounts)
docker run -d --name db -v /Users/rfloresp/SEProjects/dockerPlatzi/mongodata:/data/db mongo

volumenes

docker volume create dbdata
docker run -d --name db --mount src=dbdata,dst=/data/db mongo

ingress
docker cp ejemplo.txt copytest:/testing/test.txt

extract
docker cp copytest:/testing localtesting

Host: Donde Docker esta instalado.
Bind Mount: Guarda los archivos en la maquina local persistiendo y visualizando estos datos (No seguro).
Volume: Guarda los archivos en el area de Docker donde Docker los administra (Seguro).
TMPFS Mount: Guarda los archivos temporalmente y persiste los datos en la memoria del contenedor, cuando muera sus datos mueren con el contenedor.

Image tools:

https://github.com/wagoodman/dive


docker run --rm -p 3000:3000 -v /Users/rfloresp/SEProjects/dockerPlatzi/docker/index.js:/usr/src/index.js platziapp
CMD ["npx", "nodemon", "index.js"] <- to have mounted a file and checking changes


Comandos:
$ docker network ls (listo las redes)
$ docker network create --atachable plazinet (creo la red)
$ docker inspect plazinet (veo toda la definición de la red creada)
$ docker run -d --name db mongo (creo el contenedor de la BBDD)
$ docker network connect plazinet db (conecto el contenedor “db” a la red “platzinet”)
$ docker run -d -name app -p 3000:3000 --env MONGO_URL=mondodb://db:27017/test platzi (corro el contenedor “app” y le paso una variable)
$ docker network connect plazinet app (conecto el contenedor “app” a la red “plazinet”)




